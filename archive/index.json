[{"content":"環境 windows10 正版Ansys (我的是教學版) python 3 目標 使用python script，執行後自動開啟maxwell、新增project\nwin32com 首先要完成的是讓python開啟maxwell，參考了網路上的一些資訊，使用win32com這個module是最方便的，因此先跑pip install pywin32裝好module。\nclient.Dispatch 開啟軟體 使用以下的方式就可以直接開啟 ansys 的電磁分析軟體。\n1 2 3 from win32com import client oAnsoftApp = client.Dispatch(\u0026#34;Ansoft.ElectronicsDesktop\u0026#34;) 看到上面的code，可能會有幾個問題\nclient.Dispatch做了什麼事?\nwin32com.client.Dispatch()是利用 微軟 提供的一個 IDispatch 的自動化介面，接收軟體的 ProgID為參數，來操作windows軟體 (來源、詳細資料) 怎麼知道，我的系統有沒有 \u0026ldquo;Ansoft.ElectronicDesktop\u0026rdquo; 這個 ProgID呢 ?\n可以在powershell打上 Get-ChildItem HKLM:\\Software\\Classes -ErrorAction SilentlyContinue | Where-Object {$_.PSChildName -match '^\\w+\\.\\w+$' -and (Test-Path -Path \u0026quot;$($_.PSPath)\\CLSID\u0026quot;)} | Select-Object -ExpandProperty PSChildName 找看看有沒有，如果太多的話可以在最後面加上 | grep An 來縮減結果。 為什麼使用 oAnsoftApp 這個Object name?\n因為這是官方的手冊裡控制軟體的API名稱，依照手冊裡的變數，之後繼續實作其他功能時對照會比較方便。\n新增project 後續所有的操控源頭都是 oAnsoftApp 這個object，首先，就來開啟一個project，用下列的code就能成功開啟。\n1 2 oDesktop = oAnsoftApp.GetAppDesktop() oProject = oDesktop.NewObject() 有任何問題歡迎留言討論~\n","description":"由 python script 自動開啟Ansys maxwell軟體、新增project","id":0,"section":"posts","tags":["motor_design_programming"],"title":"","uri":"https://markwengstr.github.io/posts/large_motor_install/"},{"content":"前言 這次想分享我到底怎麼從零轉職網頁全端工程師的，轉職之前是什麼背景、具備什麼基礎、是什麼原因讓我想要轉職、如何真的轉職成功、轉職成功後遇到什麼困難、如何克服這些困難、而最後又為什摩要回到馬達的領域裡面。\n轉職前的背景 在成大研究所時期主要研究馬達設計，使用的工具是Ansys Maxwell (那時候叫做Ansoft)以及JMAG，而老師給的題目是沒人做過的，沒有學長姐可以問，老師給予的輔助也比較少，需要自己看書找人問。\n但也是因為這樣，自己摸索的過程當中對於電磁原理、轉動機械產生了很高的興趣，受當時給我建議的何博、明賢哥很大的影響，做任何設計之前，需要先了解基礎的物理公式，先用計算的方式得出設計，再來設計細節。\n為什麼要轉職 研究所畢業後順利的進入台達做研替，產品是目前最火紅的電動車的馬達，但進入業界之後，發現電磁分析的設計，到最後實際成品，其實有一段非常大的差距，單純模擬是很難獨自開發產品的，而且做產品跟做研究是非常不一樣的，做產品的成本非常高，需要的是不斷的優化，因此常常在修改參數、跑模擬、然後再修改參數、再跑模擬。\n在優化模擬的過程中，如果每一次只修改一點尺寸就需要重新畫一張CAD，這過程中常常會做許多的重複動作，因此我開始思考有什麼比較簡化的方式，一開始是使用Ansys裡面所提供的尺寸參數化，但隨著我想做的自動化功能越來越多，像是自動判斷結果數值並作出反應，就需要一些程式來輔助。\n其實ANSYS本身就有提供python控制的方式，但是當時沒什麼資訊，我只會寫一點點的matlab，用python根本就是天方夜譚，但那時候就產生一個想法，如果我會寫程式的話有多好，我就可以用程式來控制這些優化過程，按一個鍵去跑，我就可以去看NBA了(誤)。\n再來是考慮到研替以後的職涯，當時看了一本書 “三年後，你的工作還在嗎？”，這本書的作者後來成立了“大人學”。我開始思考依當時的狀況，自己算是最小戰鬥單位： 行腳商人、總管、工匠的哪一個？ 工程師看起來是工匠，但對於馬達這個產品的工匠來說，我會的模擬分析，應該只能算是10%的工匠。\n那有沒有什麼技能是可以成為獨自就能創造產品的工匠呢？ 當時找到的答案就是學習成為網頁全端工程師。\n如何轉職 找課程 大概是研替結束的前半年，開始想要成為網頁全端工程師後，就開始檢視自己會什麼，要找什麼課程來補強。我只會寫一些基本的matlab code，這對於寫網頁是否有用？ 答案是沒有。我連html是什麼鬼都不知道，所以要找的課程就是要完全新手的課程，google了網頁全端的課程，當時剛好Alphacamp第一次辦線上課程，也搞不清楚Ruby on Rails是什麼就報名了。\n學習網頁開發的過程 Alphacamp當時做的最好的一件事就是有幫我們分組，一起討論專案的感覺真的很不錯，互相激勵學習也會督促自己別偷懶，而且我們這組四個雖然沒有上Demo day，但是全部都有轉職成功，現在也在軟體業裡面工作。\n另外一個從Alphacamp學到的方式就是記錄自己的學習，這我一直非常受用至今，不過當時的單純紀錄課程學習是不太夠的，應該要記錄解決問題的過程。\n寫到這裡，想探討一下花錢上Alphacamp的課到底有沒有幫助呢？\n說實在除了在基本的網頁、程式知識、紀錄習慣與分組討論很不錯之外，後面工作上的幫助是非常的少。他們已經做得很不錯了，這其實是我自己學習心態的問題，我覺得沒幫助是因為當時並沒有想用程式解決的問題，只是單純想要找到網頁全端的工作，所以可能會一直去看104上的求職條件，找面試會問的問題，把面試問題的解法背下來，想說這樣就可以找得到工作。\n當時的我也沒有對程式有興趣，當然不會去深入瞭解每行code，都是在抄課程的範例，作業的部分當然會自己做，但就不會更深入想去多瞭解。所以一直到做完期中專案，對於整個rails的架構其實還是一知半解。唯一比較有學到東西的一次，是因為做期中專案的時候有發現排序上的問題，花了九牛二虎之力才發現是ruby跟rails所給的function有排序上的差異所造成。\n轉職成功 既然當時的程度這麼爛，到底怎麼找到工作的呢？ 禱告，就真的是靠著一直禱告，運氣很好的在面試第五間的時候，到了一間港商金融公司，被問到一個關鍵問題 “有沒有在學習的過程中遇到問題，如何解決”，我把上面發現排序問題的過程講了出來，表現出了一個 “邏輯清晰，具備解決問題的能力” 的有潛力的人的形象(這我後來有跟主管印證)，前四間在還沒被問到這個問題的時候就因為被發現寫code能力太差而失敗。\n回顧與檢討 現在來看，比較好的方式應該是，邊上課邊從當時的工作上直接尋找能用網頁來解決的問題，當成工作一的部分，再透過解決問題來學習，並且記錄下解決問題的過程，之後再透過複習這些解決過的問題再來問延伸問題，再想辦法解決並記錄下來，這才是比較好的學習方式。\n這樣有幾個好處\n當成工作，比較不會覺得是額外花時間學新東西，如果是額外花時間，常常會覺得想偷懶，當成工作的話比較會有責任感來完成。 真正學到的東西都是從解決問題後累積起來的，透過程式解決問題的過程必定會對程式有更多了解。 透過複習解決過的問題，去延伸其他問題有非常多的好處。 培養問問題的能力： 為什麼這樣可以成功，如果換成其他方式可不可以成功…等，這個能力在後續工作非常非常的重要。 加深這個問題的印象：當反覆思考之後，問題的解決方式就變成你的自然反應，忘也忘不了。 同一款問題其實有很多個面向：其實可以透過這樣的方式把問題整個深思熟慮過，思考的層級會比第一次解決的時候還要高。 下期預告 找到工作後就一帆風順了嗎？ 當然不是，真正痛苦的才剛開始，就留著下篇文章再來分享吧，敬請期待~!\n","description":"這次想分享我到底怎麼從零轉職網頁全端工程師的，轉職之前是什麼背景、具備什麼基礎、是什麼原因讓我想要轉職、如何真的轉職成功、轉職成功後遇到什麼困難、如何克服這些困難、而最後又為什摩要回到馬達的領域裡面。","id":1,"section":"posts","tags":["轉職"],"title":"30歲轉換跑道，離開大企業穩定工作從零轉職網頁全端工程師，歷程分享(1)","uri":"https://markwengstr.github.io/posts/job_trans_1/"},{"content":"為什麼要寫這篇 因為工作的關係，常常接觸高壓電機的保養與相關測試，當然高壓電機線圈的部分放電也是一個非常重要的部分，最近剛讀完規範，就想說來記錄一下讀到的東西，也希望可以在這部分有更多的精進，之後會再繼續分享有關高壓馬達保養與測試的知識。\n為什麼要測PD(Partial Discharge)? 用來觀察絕緣的品質 (老化的影響與潛在缺陷) 判斷絕緣的老化程度 定期追蹤絕緣狀態 PD的測量方式 online: IEC 60034-27-2 offline: 此篇 測量PD的限制 雜訊不能太大 溫度, 濕度需控制在一定範圍 規範適用條件 僅使用於頻率範圍 0.1-400hz, Interpretation guidelines適用的範圍為 50~60hz(電機), 45-65(power supply) 繞組需為 bar or coil所成形 線圈需有導體的塗層，通常為6kV以上的電機 常用名詞解析 PD(partial discharge): 在導體與絕緣間隙間發生的部分放電 stress control coating: groundwall insulation 外的塗層或tape，目的是要平緩高壓定子線圈的電位 conductive slot coating: 承上，為導電的塗層，通常稱為半導塗層 slot discharges: 發生在定子鐵芯與線圈外層絕緣的放電 internal discharges: 發生在groundwall insulation的放電 surface discharges: 絕緣的表面(端部或active part)的放電 largest repeatedly occurring PD magnitude(Qm): 每秒重複10次的最大脈衝值 電機中的PD特性 為什麼會有PD? 絕緣中的電介質特性並非全部都是均質的，造成某些地方電場強度過強至介電崩潰，其不會直接造成絕緣的破壞，但造成了絕緣壽命的減少。 PD發生的地方 非均質的電介質(絕緣中的氣泡, 絕緣與導體間隙\u0026hellip;)都會出現 造成PD的原因 絕緣與繞線..等 製造上的瑕疵 操作時間久了之後，因電氣, 熱, 機械\u0026hellip;等等的影響所造成的絕緣衰弱 PD的種類 Internal voids Internal delamination: 由於機械或熱的壓力過大，造成主絕緣的脫層，越大的空洞會造成越高能量的放電，造成非常明顯的惡化。 另外脫層也會造成熱傳導的降低，更加速絕緣的老化。 若發生此現象，需特別小心。 Debonding(脫膠) between insulated conductor and groundwall insulation: 這會造成過熱以及機械上的壓力，容易造成更大面積的脫膠 Slot discharges 通常為塗層雜質產生的高電場強度或是線圈bar的位移(wedging 壓力不足)，使得電磁震動造成摩擦，所造成的半導塗層脫落\nEnd-winding gap and surface discharges 通常發生在定子線圈懸空部分，其不同材質的介面處，可能是不好的介面設計、雜質髒污、小空隙很多、熱影響\u0026hellip;所造成\nForeign conductive materials discharges 破損、老化的螺栓或螺絲，甚至是無意間忘在馬達中的工具，都會造成部分的電場集中，或是機械性的損壞絕緣\nPulse propagation in windings PD 產生時為非常高頻的瞬間突波，經過一連串的電容電感效應可能產生電磁共振，產生一些可能會被量測到的週波，可能是非常高頻的突波，會影響整體PD的量測\n設備與安全 測試設備的電壓需能產生以下電壓 Upp/Urms = 2 2 , ± 5 % (Upp is Upeak to peak, Urms is U root mean square).\n需有過電流保護的relay，且有斷路器以防flashover 做好圈圍 需至少兩個人來操作 測試設備準備 保持設備連接點的乾淨(接點, 線材\u0026hellip;等，可先用氣噴槍清潔) 建議先進行絕緣電阻測量 高壓線圈需保持周邊乾淨 測試調整 PD通常在1分鐘的時間內會慢慢遞減 最高電壓的測試要低於5分鐘 測試電壓 用0.2Vmax為刻度 降低noise 用已經成熟的量測裝置 把連接的設備放置在測試電機的附近 需照著上面winding diagram的方式，power supply與連接測量設備在電機的兩端，讓雜訊可以透過馬達線圈被削弱 所有RTD都要確實接地 標準化測試流程，定時校正測試設備，隨身攜帶的變壓器有可能會因為現場的狀況而越來越髒，越來越老化 接地需要是好的(大範圍地)，測試設備、電機、連接unit都需要在同一個接地 讓所有的測試裝置盡量靠近 量測的線材需是成熟的，其電阻需符合整體量測，不會造成反射情況的 電腦或螢幕裝置可能會造成雜訊 可以使用濾波器 定位PD發生的位置 最好的方式是用PRPD pattern，也就是一個正弦波週期下的PD圖譜。 最好要各相分開測量，如果三相同時供電，端部的放電信號會被削弱。 off-line的好處就是，可以掀開護蓋觀察線圈情況，或是把轉子抽出觀察。 解釋PD測量結果 每台電機因為製造的細微差別，啟動停止與運作時間不同，都會有不同的PD放電反應 stress control coating在線圈懸空的部分，其PD的發生不只有線圈實體上的影響，頻率也會影響，越高的頻率，可能會導致額外的PD發生在線圈overlap的部分。 能完整比較PD的測量方式 同一顆定子、同一台量測設備、同一種測量方式，隨著時間定期量測追蹤 放電量Q的趨勢 新定子可能會有相對高的PD，會隨著開始使用後慢慢降低 不同時間點，電壓需在正負 2.5%、溫度需在正負10%，且用同一套量測設備 氣壓需要一樣 放電量Q的變化 正負 25%，在統計上還算合理 不同定子但相同規格，同一台量測設備、同一種測量方式，放電量Q的比較 同一顆定子，不同相放電量Q的比較 結論 對於高壓電機來說，絕緣不良導致電機損壞的機率是一半以上，但願這篇文章可以提供大家一些有用的資訊，測量高壓電機的時候也要保護好自己，有問題也可以私訊我討論喔~，雖然我還是比較喜歡寫程式，但對於這些物理現象也是很有興趣的!\n","description":"study note of IEC 60034-27-1 (Off-line partial discharge measurements on the winding insulation)","id":2,"section":"posts","tags":["motor_knowledge"],"title":"電機工程師、儀電工程師必看，IEC 60034-27-1 簡述，離線部分放電測量繞阻絕緣規範","uri":"https://markwengstr.github.io/posts/iec60034_27_1_study/"},{"content":"為什麼會思考這個? 八月份時，為了之後在高雄的新生活，也剛好看到了一間研究所時代非常憧憬的公司，義無反顧的就投了，在慌亂的整理快十年來的履歷的同時，開始思考\n研究所的時候做馬達設計，有磁路的概念；第一份工作繼續做馬達設計，有馬達設計的實務經驗；第二份工作寫網頁，有網路的知識與網頁開發的概念。 但我到底累積了什麼？ 我到底如何證明這些知識是有累積起來的？\n結論 仔細回想，每個時期印象最深刻的，就是那個當時覺得最難解決的問題，最深刻也學到最多，無論是技能、做事、做人都是。\n而對我來說，所謂的天賦或熱情，就是當面對困難，努力解決之後，仍然對這一個領域的問題感到興奮，期待能繼續解決更困難的問題。\n期待我在新的工作中，能夠持續地解決 「困難」的問題，累積出屬於我的人生。\n","description":"對於自身技能累積的體悟","id":3,"section":"posts","tags":["mindset"],"title":"工作雜記 — 「累積」就是不斷地解決「困難的」問題，並記錄下來。","uri":"https://markwengstr.github.io/posts/work_exp1/"},{"content":"前言 最近也剛好有朋友有個wordpress後台功能擴增的需求，一個小型的商品ERP，由於在wordpress裡面，因此直接使用wordpress當後端API，而前端就用Vue，練一下這兩個這幾年非常夯的framework。\nUse Vue-cli in Wordpress admin page 以為Vue跟wordpress都是很多人在使用的工具，應該很好找學習資源，個別找是真的蠻多資源沒錯，但是兩個加在一起的教學就非常的少，不然就是非常複雜，沒有比較簡單能上手的工具，找了很久之後終於找到了這篇文章， 需要做一些設定，之後再使用vue-cli在wordpress裡面hot-reload開發Vue。\n專案連結在此。\nWordpress wp_rest_controller 後端部分因為已經習慣使用model與controller的方式開發，還好wordpress也提供了wp_rest_controller的工具，可以做好router與controller的部分，跟db溝通的部分拆出一個repository來使用。\n為了讓以後開發能夠有基礎可以參考，我製作了一個簡單的CURD的branch，把前端Vue與後端wordpress串起來。\n這個專案也有將常用的vue-boostrap, font-awsone裝到切開的branch供以後的專案使用，歡迎有興趣使用Vue開發wordpress plugin的朋友們一起討論~~。\n","description":"使用vue搭配vue-cli來開發wordpress plugin","id":4,"section":"posts","tags":["vue","wordpress"],"title":"Wordpress plugin development by Vue.js (vue-cli setting, hot reload)","uri":"https://markwengstr.github.io/posts/vue-wordpress/"},{"content":"現實總是變化多端 好久寫文章了，最近做的東西離馬達設計的開發越來越遠，有時真是有點徬徨，感覺跟當初回台南的預期不太相符，慢慢地體會到現實總是無法掌控的，畢竟世界不是繞著自己旋轉，不過在持續學習的原則下保持彈性是好的。工作上也使用了一些以前沒有接觸過的工具，還蠻有趣的像是elasticsearch (ELK)的架設、logstash設定、各種ES的API操作\u0026hellip;等等，之後也可以來寫一下。\n上帝的意念高過我們的意念 耶穌升天後，進入了初代教會使徒的時代，各種神蹟彰顯，教會人數倍增，弟兄姊妹和平相處，凡物共用，聖靈時常充滿門徒，我想如果我是當時的門徒，一定覺得初代教會的狀態根本就是上帝給門徒們最終的命定，持續的擴張，並把福音傳到全世界。\n不但彼得約翰講個道就幾千人信主，還會自己找上門，且各種徵兆都象徵上帝的同在。\n但這樣美好的景況卻在司提凡被處死之後瓦解，門徒逃到四處各地。\n而門徒逃到各地之後，逃到哪裡，就把福音傳到哪裡，保羅也在這時候被興起。\n如果還是維持在原本初代教會的狀態，也許上帝很難讓保羅興起，而福音需要更久才能傳的更廣。\n結論 聖經說要心意更新而變化，才能查驗何為神良善、純全、可喜悅的旨意，所以換個角度想，也許上帝最終要我走的方向是個更全面的開發者，而不單單只是開發馬達設計工具，保持持續的學習與進步才是最重要的。\n","description":"人生體悟","id":5,"section":"posts","tags":["mindset"],"title":"現實總是變化多端，因此在原則下保持最大的彈性是重要的","uri":"https://markwengstr.github.io/posts/mind_renew/"},{"content":"問題描述 重灌了幾次ansys，又灌了其他軟體之後，突然某一天發現用 oAnsoftApp = client.Dispatch(\u0026quot;Ansoft.ElectronicsDesktop\u0026quot;) 無法正常開啟anays軟體，錯誤為 com_error: (-2147221164, '類別未登錄', none, none)。\n使用ipython來執行，詳細問題如下 :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;ipython-input-2-9633b38a1caf\u0026gt; in \u0026lt;module\u0026gt; ----\u0026gt; 1 client.dynamic.Dispatch(\u0026#34;Ansoft.ElectronicsDesktop\u0026#34;) c:\\python37\\lib\\site-packages\\win32com\\client\\dynamic.py in Dispatch(IDispatch, userName, createClass, typeinfo, UnicodeToString, clsctx) 125 def Dispatch(IDispatch, userName = None, createClass = None, typeinfo = None, UnicodeToString=None, clsctx = pythoncom.CLSCTX_SERVER): 126 assert UnicodeToString is None, \u0026#34;this is deprecated and will go away\u0026#34; --\u0026gt; 127 IDispatch, userName = _GetGoodDispatchAndUserName(IDispatch,userName,clsctx) 128 if createClass is None: 129 createClass = CDispatch c:\\python37\\lib\\site-packages\\win32com\\client\\dynamic.py in _GetGoodDispatchAndUserName(IDispatch, userName, clsctx) 112 else: 113 userName = str(userName) --\u0026gt; 114 return (_GetGoodDispatch(IDispatch, clsctx), userName) 115 116 def _GetDescInvokeType(entry, invoke_type): c:\\python37\\lib\\site-packages\\win32com\\client\\dynamic.py in _GetGoodDispatch(IDispatch, clsctx) 89 IDispatch = pythoncom.connect(IDispatch) 90 except pythoncom.ole_error: ---\u0026gt; 91 IDispatch = pythoncom.CoCreateInstance(IDispatch, None, clsctx, pythoncom.IID_IDispatch) 92 else: 93 # may already be a wrapped class. com_error: (-2147221164, \u0026#39;類別未登錄\u0026#39;, none, none) Debug路程 確認Prog_id是否存在 使用 分析自動化一 的方式，確認是否存在 prog_id: Ansoft.ElectronicsDesktop 。 有!\n由於之前的認知只到這裡，第一次遇到有了prog_id還不能呼叫，google了一下，找到了這篇，還有一堆其他的，都是說python要用32位元才行，一開始想說應該不是這個問題，因為以前都可以正常呼叫，但找不到其他資料了，就試試看吧。\n重灌python 32位元與pip 還好用 Chocolatey 卸載跟安裝都超級快的，但是安裝了32位元的python後，還是無法執行呀!!!\n註冊com object by regsvr32 試了上面的方法都不行，看來只能去研究windows的com元件了，首先確認一下 類別未登錄 這個錯誤訊息，亂打一個 client.Dispatch(\u0026quot;xxx\u0026quot;)，錯誤訊息是不一樣的，代表其實真的抓的到prog_id，只是在windows的某個地方 python抓不到 這個com object，那就來看怎註冊這個元件瞜。\n經過了一段時間的找資料後，跟著 windows官網指示 做了之後還是不行，其實說實在我根本不知道要註冊哪一個dll，所以就到ansys的資料夾裡面，把所有跟ansoft有關的dll都註冊了一次，但還是不行呀!!!。\n解決方法 - regserver 又嘗試了一段時間，最後想到，其實只是單純想用python去開啟 ansysedt.exe，那有沒有方法是直接註冊 64位元的 exe檔呢，於是找到了 regserver 的方式，在powershell中進到 AnsysEM\\AnsysEM19.5\\Win64 的資料夾中，執行 .\\ansysedt.exe /regserver ，就可以成功開啟了，太開心拉!!!\nAnsys 2021R1 找不到win32com (2021/1/30 update) 據同為 motor design programming的朋友來信，據說Ansys 2021R1的版本用regserver會抓不到win32com，解決方法是要安裝更新版的pywin32 https://github.com/mhammond/pywin32/releases\n歡迎來信一起討論優~!\n","description":"由 python script 自動開啟Ansys maxwell軟體時，遇到 com_error(-2147221164, '類別未登錄', none, none) 的解決方法","id":6,"section":"posts","tags":["motor_design_programming"],"title":"python開啟ansys軟體問題 (2147221164, '類別未登錄')","uri":"https://markwengstr.github.io/posts/ansys_init_2/"},{"content":"目標 由定子外徑限制、最大功率、DC bus電壓、最大轉矩、最高轉速 規格，推導出整個10p12s spm馬達的設計與細部尺寸，並不是一個優化的模型，但都是經由合理的計算與假設，實作出一個合乎規格的初始設計。\n設計概覽 規格如下\n1 2 3 4 5 6 7 { \u0026#34;stator_OD_limit\u0026#34;: 120, \u0026#34;max_power\u0026#34;: 5000, \u0026#34;voltage_dc\u0026#34;: 48, \u0026#34;max_torque_nm\u0026#34;: 27, \u0026#34;max_speed_rpm\u0026#34;: 5000, } 整個 設計計算 可以參考連結\n設計流程簡介 先看到整個script最底下的 mech_structure_cal 的計算\n1 2 3 4 5 6 7 def mech_stucture_cal(total_cal_params): assign_spec_value(total_cal_params) and \\ ktke_calculation(total_cal_params) and \\ expend_NBLR(total_cal_params) and \\ expend_stator_teeth_york(total_cal_params) and \\ expend_stator_slot(total_cal_params) and \\ expend_magnet(total_cal_params) 清楚的看到，流程就是\n將規格參數先塞到整個計算流程會用到的參數上 為什麼要這樣呢? 因為將用到的參數(state)統整在同一個地方，這樣方便管理、修改與debug 計算ke, kt，馬達最重要的兩個參數 由ke展開 線圈匝數、氣隙磁密、馬達有效長度、氣隙半徑 展開定子槽尺寸參數 展開轉子磁石參數 設計流程說明 以下談到的參數與係數都在 設計所需參數 中。\nktke_calculation ktke的計算說明可以參考 淺談馬達設計 這篇\n相ke計算式為 相電壓 peak / 轉速 ( V / rad/s )，而DC bus 等同於 線對線電壓 peak值，轉成相電壓需由線電壓除 $\\sqrt{3}$ 。 而通常為了保證實務上電子元件的一些壓降，會乘一個係數 (voltage_buffer) 由ke換算kt，其實理想上應該是ke = kt，但由於最大轉矩時可能會有一些非線型的kt產生，因此也會乘上一個 kt_ke_ratio的係數來輔助，讓最後模擬出的結果是能達到規格的 由最大轉矩與kt計算出所需要的 最大電流。 expend_NBLR 由合理的 轉矩密度(Torque Density) 與 規格給的外徑限制 得到 馬達有效長度，計算時取無條件進位到整數。 由合理的 定轉子外徑比 與假設之 氣隙磁密值 來得到 匝數(coil turn)，取無條件進位整數。 (其實這個部分有些經驗與猜測的成分，如果有更好的方法也可以來信與我討論。) 由上述算出的 匝數 來計算 轉子半徑 expend_stator_teeth_york 由磁鐵與定子齒部的比例，計算出 定子齒部寬 由合理的 齒軛比，計算出 定子軛部寬 expand_stator_slot 由 最大電流 除以 (合理的最大電流密度 * 導體面積 * 並聯迴路數) 取無條件進位整數 得到 並聯導體數 由 並聯導體數 * (導體面積 + 膜厚) * 匝數 * 2 得到 槽內繞組面積 由於定子齒軛寬與定子外徑限制都已知道，而直接用限制的定子外徑的話，定子槽可能會太大 (因為轉子的外徑是由一個比例先行決定的)，且因定子齒部決定，定子槽寬是不能動的，因此由 while loop 疊代算出 符合 槽滿率 的 定子槽高。 (如果超過定子外徑限制，但還沒達到預期槽滿率的話，就用定子外徑限制，原則上如果電流密度沒有低到不合理的話不會)。 expand_magnet 由 合理的 pc 操作點，由 磁石寬度比例 與 氣隙長度 計算出 磁石厚度。\n結論 (conclusion) 上述的計算，已經把整顆馬達所需要的參數與細部尺寸都設計完了，馬達設計其實要考量的要素很多，每個設計者也會有自己的一套方法，以上是我自己的方法，確實是可以由計算就展開成一個合理且符合規格的設計，目前僅限10p12s，未來希望可以成為一個General的設計方式，可以設計各種槽極配，且能延伸到IPM或感應馬達。\n","description":"由定子外徑限制、最大功率、DC bus電壓、最大轉矩、最高轉速 規格，推導出整個10p12s spm馬達的設計與細部尺寸，並不是一個優化的模型，但都是經由合理的計算與假設，實作出一個合乎規格的初始設計。","id":7,"section":"posts","tags":["motor_design_programming"],"title":"程式化永磁馬達設計 by python 真實範例","uri":"https://markwengstr.github.io/posts/spm_motor_design/"},{"content":"Why use program to design motor Save labor cost - program 具有自動化的好處，重複的步驟只要編寫一次，之後只需要執行程式就好 Code represent design concept and step - 當設計變成code，並且利用的是好理解且通用的 code structure ，人員轉換造成的工作問題就會下降，因為所有人只要能看懂code，就能看懂設計步驟，進而理解設計。 How to represent motor design concept and step 專注在兩個非常重要卻又簡單的東西 data \u0026amp; function。\nInput \u0026amp; Output Data 先思考 input 與 ouput的data是什麼\ninput data - 規格 output data - 定子外徑、馬達長度、匝數、BEMP(@1000rpm)、操作點數據(torque data, average torque, speed, torque ripple, current, current density, line voltage, coreloss, copperloss) Design function and data 手算一次將 規格 轉換成 馬達模型數據 與 電氣數據。 將中間所有的 步驟，以及當中用到的 數據名稱 記錄下來。 將 數據名稱 根據 步驟 的概念分類 (定轉子、磁石、電氣\u0026hellip;等)。使用 dict 這個 data structure將其收起來，還不知道的值就先給 None，用專案中馬達設計的部分呈現如下。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 motor_cal_params = { \u0026#34;stator\u0026#34;: { \u0026#34;OD_limit\u0026#34;: None, \u0026#34;slot\u0026#34;: 12, \u0026#34;shoes_height_front\u0026#34;: 1, \u0026#34;shoes_height_back\u0026#34;: 1, \u0026#34;slot_open\u0026#34;: 4.5, \u0026#34;slot_corner_arc\u0026#34;: 0.5, }, \u0026#34;rotor\u0026#34;: { \u0026#34;pole\u0026#34;: 10, \u0026#34;mag_emb\u0026#34;: 0.8, # easier magetization }, \u0026#34;coil\u0026#34;: { \u0026#34;conductor_OD\u0026#34;: 1, \u0026#34;y_para\u0026#34;: 1, \u0026#34;membrane_ratio\u0026#34;: 1.075, \u0026#34;slot_fill_factor\u0026#34;: 0.43, }, \u0026#34;estimate\u0026#34;: { \u0026#34;kt_ke_ratio\u0026#34;: 0.9, \u0026#34;max_J\u0026#34;: 18, \u0026#34;voltage_buffer\u0026#34;: 0.9, \u0026#34;torque_density\u0026#34;: 25, \u0026#34;teeth_mag_ang_ratio\u0026#34;: 0.6, \u0026#34;york_teeth_ratio\u0026#34;: 0.7, \u0026#34;rotor_OD_ratio\u0026#34;: 0.6, \u0026#34;bg\u0026#34;: 1.2, \u0026#34;mag_pc\u0026#34;: 7.5, # for not easy to broke }, \u0026#34;calculation\u0026#34;: { \u0026#34;est_rotor_OD\u0026#34;: None, \u0026#34;est_stator_OD\u0026#34;: None, \u0026#34;mag_thick\u0026#34;: None, \u0026#34;teeth_width\u0026#34;: None, \u0026#34;york_width\u0026#34;: None, \u0026#34;slot_height\u0026#34;: None, \u0026#34;slot_width_front\u0026#34;: None, \u0026#34;slot_width_back\u0026#34;: None, \u0026#34;para_conductor\u0026#34;: None, \u0026#34;coil_turns\u0026#34;: None, \u0026#34;real_slot_fill_factor\u0026#34;: None, }, \u0026#34;material\u0026#34;: { \u0026#34;stator\u0026#34;: \u0026#34;\\\u0026#34;35CS250_steel\\\u0026#34;\u0026#34;, \u0026#34;rotor\u0026#34;: \u0026#34;\\\u0026#34;35CS250_steel\\\u0026#34;\u0026#34;, \u0026#34;magnet\u0026#34;: \u0026#34;\\\u0026#34;N44SH_20deg_mag\\\u0026#34;\u0026#34;, \u0026#34;coil\u0026#34;: \u0026#34;\\\u0026#34;copper\\\u0026#34;\u0026#34;, }, \u0026#34;setting\u0026#34;: { \u0026#34;cycle\u0026#34;: 1, \u0026#34;split_step\u0026#34;: 50 }, \u0026#34;voltage_dc\u0026#34;: None, \u0026#34;length\u0026#34;: None, \u0026#34;airgap\u0026#34;: 0.5, \u0026#34;w_factor_10p12s\u0026#34;: 0.933, \u0026#34;ke\u0026#34;: None, \u0026#34;kt\u0026#34;: None, \u0026#34;corner_speed_rpm\u0026#34;: None, \u0026#34;max_speed_rpm\u0026#34;: None, \u0026#34;max_current_rms\u0026#34;: None, \u0026#34;core_loss_factor\u0026#34;: 1, } 將步驟拆成小的function，專案中馬達設計的部分如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def ktke_calculation(total_cal_params): # 計算 total_cal_params 的某個值 [calculating some value of total_cal_params dict] # 將 計算值 替算掉原本在total_cal_params中的未定值 [Replace the dict value by calculated results] return total_cal_params def assign_spec_value(total_cal_params): # 計算 total_cal_params 的某個值 [calculating some value of total_cal_params dict] # 將 計算值 替算掉原本在total_cal_params中的未定值 [Replace the dict value by calculated results] return total_cal_params def expend_NBLR(total_cal_params): # 計算 total_cal_params 的某個值 [calculating some value of total_cal_params dict] # 將 計算值 替算掉原本在total_cal_params中的未定值 [Replace the dict value by calculated results] return total_cal_params def expend_stator_teeth_york(total_cal_params): # 計算 total_cal_params 的某個值 [calculating some value of total_cal_params dict] # 將 計算值 替算掉原本在total_cal_params中的未定值 [Replace the dict value by calculated results] return total_cal_params def expend_stator_slot(total_cal_params): # 計算 total_cal_params 的某個值 [calculating some value of total_cal_params dict] # 將 計算值 替算掉原本在total_cal_params中的未定值 [Replace the dict value by calculated results] return total_cal_params def expend_magnet(total_cal_params): # 計算 total_cal_params 的某個值 [calculating some value of total_cal_params dict] # 將 計算值 替算掉原本在total_cal_params中的未定值 [Replace the dict value by calculated results] return total_cal_params 將 3. 的數值dict貫穿 4. 的所有function (3.的 motor_cal_params 放在 ctx[params]中) 1 2 3 4 5 6 7 8 9 10 total_cal_params = ctx[\u0026#34;params\u0026#34;] ktke_calculation(total_cal_params) and \\ assign_spec_value(total_cal_params) and \\ expend_NBLR(total_cal_params) and \\ expend_stator_teeth_york(total_cal_params) and \\ expend_stator_slot(total_cal_params) and \\ expend_magnet(total_cal_params) print(total_cal_params) Ansys maxwell 的溝通部分也是用同樣的方式，可參考 這裡 Conclusion 使用上述的方法，是不是很單純，且很直觀就能看懂設計的過程，debug也非常容易，執行程式時將total_cal_params 印出來看就好。\n當整個程式設計完成後，接下來就是去優化每一個 function \u0026amp; data 讓它們更容易被看懂，更能直觀的對應馬達設計。\n更詳細可參考我的設計，未來還會持續的優化設計。\n","description":"Introduce how to use python in motor design and why use program to design motor。","id":8,"section":"posts","tags":["motor_design_programming"],"title":"程式化永磁馬達設計概念 by python","uri":"https://markwengstr.github.io/posts/python_ansys_concept/"},{"content":"馬達 (電動機) 是什麼? (What\u0026rsquo;s electric machine) 最近可以看到電動車在路上到處跑了，雖然目前還算是有錢人的玩具，但未來普及應是不在話下，而電動車的動力來源，就是 馬達 。 當然不只電動車用到馬達，其實日常生活中到處都是馬達，筆電風扇、洗衣機、機器手臂\u0026hellip;等，任何要讓機械動起來的源頭都是馬達。\n而馬達是什麼? 維基百科 裡面提到，最重要的原理就是 電能 -\u0026gt; 機械能 ，描述的更準確一點，其實是 電能 -\u0026gt; 磁能 -\u0026gt; 機械能 。\n馬達設計 是什麼? (What is motor design) 馬達設計，就是設計 電能 -\u0026gt; 磁能 -\u0026gt; 機械能 中間的 磁能， 讓電能 有效率 的轉換為機械能。 也就是可以在有限制的體積、重量條件，達成最大的輸出功率以及效率，因此評估馬達的指標通常會使用轉矩密度、功率密度、效率\u0026hellip;等指標。\n勞倫茲力 (Lorentz force) 勞倫茲力 (Lorentz force) : F (force density) = $\\sigma$( charge density) E (electric field)+ J (current density) x B (magnetic density)\n先來談談電磁力的源頭 - 勞倫茲力 ，為了讓大家不要看到這邊就關掉，不考慮第一項電場力，我們可以回想一下高中一個很簡單的公式，長直導體電流在磁場裡的作用力 - f (電磁作用力) = i (電流) * l (磁場中的導線長度) * B (磁通密度) * sin (垂直分量) ，其實就是勞倫茲力計算得到的。\n換算馬達轉矩 Torque 如果是旋轉電機的話，f = ilB 會怎麼樣變化呢 ?\n單極的電磁轉矩： 首先加上轉軸距離 (轉子半徑) r -\u0026gt; T = ilBr N, S極：馬達裡的磁鐵有N, S極，線圈也是一進一出，因此真正的轉矩為 T = 2ilBr n條導線：若是不只一條導線有n條導線，則轉矩為 T = 2ilBrn 反電動勢 ( Back - EMF) $\\epsilon=vBl$\n相信上述公式，大家應該也不陌生，長直導線在固定磁場以v速度前進，一樣因為勞倫茲力的磁場力的作用，在長直導線上會產生一個電場 (電壓) 。\n一樣考慮是旋轉電機的話 $\\epsilon=vBl$ 會怎麼樣變化呢?\nv = $\\omega$ * r : $\\epsilon= \\omega rBl$ NS極：馬達裡的磁鐵有NS極，線圈也是一進一出，因此 $\\epsilon= 2 \\omega rBl$ n條導線：若是不只一條導線有n條導線，則轉矩為**$\\epsilon= 2 n \\omega rBl$** 馬達參數 (motor constant) Kt, Ke 將上述兩個計算公式的結果擺在一起，來對照一下差異\n轉矩公式: T = 2ilBrn\n反電動勢公式: $\\epsilon= 2 n \\omega rBl$\n稍微整理一下\nT = 2nBlri = Kt i\n$\\epsilon= 2 nBlr \\omega$ = Ke $\\omega$\n有沒有發現，其中的 2nBlr 是重複的，又可稱為馬達參數 Kt, Ke，而兩側的 T, i, $\\epsilon , \\omega$ 其實就是電氣規格與機械規格，\n如果把上述兩個公式相除，交叉相乘後， $\\epsilon$ * i 其實就是電功率， T * $\\omega$ 其實就是所謂的 機械功率 ，再將時間項除掉後，其實就呼應文章最一開始的 電能 -\u0026gt; 機械能 。\n馬達設計重點參數 (Parameters of motor design) 2nBlr 自然就是磁的部分了，也點出了馬達裡面最重要的四個參數\nn(線圈匝數) 、\nB(定轉子氣隙磁通密度)、\nl(馬達有效長度)、\nr(定轉子氣隙半徑)，\n永磁馬達設計就是圍繞著這四個參數來執行設計。\n接下來的文章就會實際的來設計拉，大家有問題的話都可以留言或是mail來討論\n謝謝收看\n","description":"馬達是一種能讓 電能 轉換成 機械能 的元件，此篇文章使用簡單好理解的方式來解釋馬達設計這件事。","id":9,"section":"posts","tags":["motor_design_programming"],"title":"淺談永磁馬達設計原理","uri":"https://markwengstr.github.io/posts/motor_principle/"},{"content":"影片介紹 (Vedio Intro) 目前的成果，拍成影片上傳到youtube上\n輸入所需的參數 spec_params [input the required parameters]\n1 2 3 4 5 6 7 8 9 10 spec_params = { \u0026#34;stator_OD_limit\u0026#34;: 120, \u0026#34;max_power\u0026#34;: 5000, \u0026#34;voltage_dc\u0026#34;: 48, \u0026#34;max_torque_nm\u0026#34;: 27, \u0026#34;max_speed_rpm\u0026#34;: 5000, \u0026#34;export_path\u0026#34;: None, \u0026#34;pj_key\u0026#34;: str(int(time.mktime(datetime.datetime.now().timetuple()))), \u0026#34;res_url\u0026#34;: None, } 稍微解釋一下參數\nstator_OD_limit: 定子外徑限制 [Stator outer diameter] max_power: 最大功率 [maximum power] voltage_dc: DC bus 電壓 [DC bus voltage] max_torque_nm: 最大轉矩 [maximum torque] max_speed_rpm: 最高轉速 [maximum speed] export_path: 輸出路徑 (not required) pj_key: project的名稱(使用不重複的時間戳，以便同時多個模擬一起執行) (not required) res_url: 打response回去的url (這是之後串接要用的可以不用管) (not required) 輸入以上參數後，執行 python run.py 就會開始 執行設計 -\u0026gt; 跑模擬 -\u0026gt; 數據計算後處理。 [execute python run.py, begin to execute design, simulation, post data processing. ]\nGithub repo: https://github.com/MarkWengSTR/ansys-maxwell-EM-design-online\n未來討論項目 接下來針對整個project的內容來講解，會分成幾個部分 [For the project content description, will break to parts]\nmotor design concept python script code design python ansys co-operation build web api 敬請期待~~~\n","description":"利用python script 自動化設計 SPM 馬達 並控制ansys maxwell 模擬。","id":10,"section":"posts","tags":["motor_design_programming"],"title":"Python script for ansys maxwell, Surface Permanent Magnet Motor design automation demo","uri":"https://markwengstr.github.io/posts/auto_design_intro/"},{"content":"環境 windows10 正版Ansys (我的是教學版) python 3 目標 使用python script，執行後自動開啟maxwell、新增project\nwin32com 首先要完成的是讓python開啟maxwell，參考了網路上的一些資訊，使用win32com這個module是最方便的，因此先跑pip install pywin32裝好module。\nclient.Dispatch 開啟軟體 使用以下的方式就可以直接開啟 ansys 的電磁分析軟體。\n1 2 3 from win32com import client oAnsoftApp = client.Dispatch(\u0026#34;Ansoft.ElectronicsDesktop\u0026#34;) 看到上面的code，可能會有幾個問題\nclient.Dispatch做了什麼事?\nwin32com.client.Dispatch()是利用 微軟 提供的一個 IDispatch 的自動化介面，接收軟體的 ProgID為參數，來操作windows軟體 (來源、詳細資料) 怎麼知道，我的系統有沒有 \u0026ldquo;Ansoft.ElectronicDesktop\u0026rdquo; 這個 ProgID呢 ?\n可以在powershell打上 Get-ChildItem HKLM:\\Software\\Classes -ErrorAction SilentlyContinue | Where-Object {$_.PSChildName -match '^\\w+\\.\\w+$' -and (Test-Path -Path \u0026quot;$($_.PSPath)\\CLSID\u0026quot;)} | Select-Object -ExpandProperty PSChildName 找看看有沒有，如果太多的話可以在最後面加上 | grep An 來縮減結果。 為什麼使用 oAnsoftApp 這個Object name?\n因為這是官方的手冊裡控制軟體的API名稱，依照手冊裡的變數，之後繼續實作其他功能時對照會比較方便。\n新增project 後續所有的操控源頭都是 oAnsoftApp 這個object，首先，就來開啟一個project，用下列的code就能成功開啟。\n1 2 oDesktop = oAnsoftApp.GetAppDesktop() oProject = oDesktop.NewObject() 有任何問題歡迎留言討論~\n","description":"由 python script 自動開啟Ansys maxwell軟體、新增project","id":11,"section":"posts","tags":["motor_design_programming"],"title":"python開啟ansys軟體、新增project","uri":"https://markwengstr.github.io/posts/ansys_init/"},{"content":"任何語言的基本概念 SICP有提到，或是可以參考網站內的文章 sicp_1a，當認識一個新語言，最重要的事情有四個\nPrimitive Object (語言的基本元素) Means of combination (組合基本對象的方法) Means of abstraction (如何抽象) Capturing common patterns (如何利用領域的專業，找到通用函數) 第四點雖然也很重要，但比較屬於系統複雜度增加後採取的作法，目前先不討論\nPrimitive Object (語言的基本元素) in python Expression and statement Expression(表示式): 寫出一段文字 or 程式碼，python的解釋器讀了之後，幫你做完裡面的事，並且回傳給你一個值 (ex: 1 + 1 回傳 2)\nstatement(陳述式): 寫出一段文字 or 程式碼，python的解釋器讀了之後，幫你做完裡面的事，但不回傳任何東西 ( a = 1 )\n(有個小問題可以思考一下，那回傳 nil算expresion還是statement呢?)\nData 字串: str\n數字: int(整數), float(分數)\n有順序的集合: list(由[]包起來的集合, 元素可以被覆蓋), tuple(由()包起來的集合, 元素不能被覆蓋)\nMapping的集合: dict(由{}包起來的集合, 由key字串值 =\u0026gt; value任意值)\nBoolean布林值: True, False\nMeans of combination (組合基本對象的方法) in python Operator 運算子: 加減乘除, 比較, 邏輯, assignment，詳細可直接看 w3cschool 判斷表示式: if...else... loop陳述式: for, while function: def xxx: ...return yyy (定義function時使用def\u0026hellip;return陳述式, 此時沒有回傳值, 使用 () 執行function時才有回傳值) 詳細可直接看 w3cschool Means of abstraction (如何抽象) in python 利用assignment指定data成為 特定名稱的 \u0026quot;變數\u0026quot; 將combination組合data且放入 特定名稱的 \u0026quot;function\u0026quot; why no class / object 看到這裡應該有人會問，為什麼沒有 class / object ?\n其實在這個自動化系統並沒有用到OOP的方式，OOP是一個很好解決複雜系統的方式，OOP的話是把每個部件定子, 轉子, 線圈, 磁石\u0026hellip;等 都做成class，要設計時將物件實體化來做設計。\n但我覺得馬達設計是一個很數學的學問，直接用規格的data貫穿所有設計的function，其實就可以達成完整設計，而完成的code structure其實也清楚且好維護。\n結論 上述所有關於python的語法非常的簡單，而且其實不單只適用於python，這些方法是所有語言都有的，也就是學會了接下來談到的設計方法後，無論轉去哪個語言，都是可以使用的，下一篇文章會利用此篇文章的基礎，先講解整個設計方法的概念。\n","description":"介紹python基本語法，所有構建自動分析所需的基本概念與python語法，都在這篇講完。","id":12,"section":"posts","tags":["motor_design_programming","python"],"title":"python fundamental concept 基礎概念","uri":"https://markwengstr.github.io/posts/python_fundamental/"},{"content":"為什麼會看這本書? 最近剛好處於一個人生的重大轉換時期，也剛好有一個多月的空閒時間，除了錄11月份去師大教課的影片，其餘時間就是練習sicp與看書。\n這本書就是偶然在聽某個財經的podcast聽到的，而剛好以前主管也有分享過，好奇心驅使之下就找了一下資訊。\n看了一下博客來 居然已經絕版了，不過找到了一個說書的影片 ，也找到一份免費的 版本。\n我想以重點摘要配上自己的心得，紀錄這段時間受到的觸動與啟發\n重點摘要與心得 這個世界上有兩種遊戲，有限遊戲與無限遊戲 有限的遊戲: 以取勝為目的 無限的遊戲: 以延續遊戲為目的 心得 :\n上面兩句話貫穿整本書，因此其他都忘了也沒關係，只要記得如果某件事情你想要贏別人、或是你覺得輸了，那就是在玩有限的遊戲。 永遠選擇無限的遊戲 有限的遊戲 有玩家獲勝即終結，而獲勝的條件是觀眾的認同 獲勝後的玩家得到頭銜，且以維持這個頭銜為目的 參與者是需要資格的，資格是所有遊戲中的玩家所界定的 參與的玩家隨時都可以撤出 玩家需在規則 (邊界) 內玩遊戲 心得 :\n社會上的每件事情都充滿了有限遊戲，工作、錢、房子、甚至小孩的成績\u0026hellip;，感覺人類的社會一直都是這樣，可能從亞當夏娃吃了分別善惡樹的果實開始的吧。\n而我們卻又深深的沉浸在這些遊戲當中，相信要扮演好某個角色，相信這個角色要贏過某些人才行。\n\u0026ldquo;相信是知道自己相信，而知道自己相信則是不相信\u0026rdquo;，我的解讀是，我們覺得在某個角色上應該要這樣，但覺得角色應該要的同時，我們其實不認同\u0026quot;應該要這樣\u0026quot;的想法。 任何領域的頭銜，都有這個性質。\n無限的遊戲 唯一的目的是\u0026quot;阻止遊戲結束\u0026quot; 每個人都有資格 參與的玩家說不清時間、空間界線，他們也不在意 樂趣在於嘗試去啟動一件無法結束的事 玩家玩的是遊戲的規則(邊界) 心得 :\n這真的是一個很值得響往的人生，仔細思考一下，有很多人已經在玩無限遊戲了，音樂、物理、天文、電腦程式\u0026hellip;太多太多人參與在其中，而且此時此刻，還有很多人參與在無限遊戲當中，繼續拓展領域的邊界。\n有時候玩音樂，會去比較誰強，我要比誰彈得更屌，這樣的想法是有限遊戲，但音樂本身是一個無限遊戲，對於無限來說，任何人的能力再強，都是微小的，我要在乎的只是，能不能在音樂的邊界上更多的推展，別人比我強，我就去學習，別人比我弱，我就去教他，我們一起把音樂的邊界推展出去，不只音樂，任何事情都是這樣。\n這本書提供給了我一個想法，我真的很喜歡寫程式的自我實現感，希望可以在馬達這種傳統領域來推廣，因此希望能創造一個 簡單且好用的 motor design programming way ，並且持續的推廣它，讓所有從事馬達設計的人，能在這個programming的基礎上，讓馬達設計更方便，且也能回過頭來一起優化這個project，後面的文章會將我所想要做的motor design programming實踐出來，不過其實對於CS領域的知識還很薄弱，還得先繼續充實自己才行。\n劇本性與傳奇性 有限遊戲是劇本性的，無限遊戲是傳奇性的 有限遊戲的玩家希望所有未來發生的事，都在自己的掌控之中，技巧完美純熟到，一上場遊戲就好像結束了 \u0026ldquo;驚奇之舉\u0026quot;經常讓有限遊戲結束，讓無限遊戲延續 心得 :\n很多的發明都是從\u0026quot;驚奇之舉\u0026quot;來的，但我覺得意思不是指什麼都不準備， 而是準備所有想的到的可能性，但並不排斥準備以外的可能性發生。\n這樣的想法，可以讓壓力下降很多，因為不再執著於每一步，而是把焦點放在整件事能不能往前推進。\n權力與力量 有限遊戲結束後產生權力 無限遊戲當中不具備權力，但具備力量 權力的數量有限，力量則無法被衡量 權力是人們在限制中擁有的自由，力量則是伴隨著限制的自由 力量是矛盾的，我有力量不是因為能通過與他人競爭的結果，去強迫別人做我想做的事，而是我能允許他們在我與他們競爭的過程中，做他們想做的事 心得 :\n我認為權力與力量是一體的兩面，任何一件事，權力是外在的強迫與壓迫，而力量是由內而外的向前推\n無限遊戲的結束 邪惡是無限遊戲的終結，在聽不見的靜默中結束 邪惡不是對權力的獲取，而是權力的表達 邪惡代表頭銜的被迫認可 邪惡從未想成為邪惡，邪惡滋生於消除邪惡的慾望 無限遊戲的玩家不試圖消除邪惡，因為這種做法正是邪惡本身的衝動，他們只是矛盾的認識到自己內心的邪惡 心得 :\n\u0026ldquo;邪惡從未想成為邪惡，邪惡滋生於消除邪惡的慾望\u0026rdquo;，這句話真的是給了我一重重的一拳，很多時候會想要糾正別人，消滅自己認為別人不對的想法或行為，甚至帶著很強烈的情緒，\n這反而滋生了邪惡，如果能使用力量，單純的表達自己的想法，讓別人自己去決定要做什麼，是不是能讓 \u0026ldquo;關係\u0026rdquo; 這個無限遊戲能繼續執行，且也能使對方在自己的無限遊戲當中繼續執行。\n死亡 死亡是有限遊戲的失敗 死亡是無限遊戲的一種過程或是手段 無限遊戲的玩家雖然不知道死亡何時會降臨，但我們總能說，他們死在合適的時候 讓過去成為過去 不允許過去成為過去，也許是有限遊戲玩家嚴肅的主要原因 只要有限遊戲的玩家還有觀眾，那玩家就希望觀眾知道誰是獲勝者 越是將自己視為獲勝者，我們就越知道自己是失敗者，因此獲勝者必須反覆證明自己是獲勝者，沒有人已經足夠富有、足夠光榮、足夠被讚譽 若我們做為自己的天才來行事，則會讓過去成為過去 讓過去成為過去，並非對過去的否認，而是透過我們的原創性而重塑過去 我是自己的天才 每個人一出生就混合了有限與無限的遊戲 天才來自於 觸動 而非 推動 只有我從自己的心中，同時而原創性的回應時，我才真正的被 觸動 將我推向一個預見或預備好的地方，叫做 推動 ，這是一個舞台化的行動 只有在推動我的時候，你保持不動，這個行動才是成功的(被觸動) 所有設計性的東西，都會被觸動所粉碎，觸動者與被觸動者能感受到的，無非是驚訝 心得:\n我有沒有被觸動的經驗呢? 我覺得有，而且有三次。\n第一次是在高中的時候，忘了什麼聚會需要幫忙彈BASS，要先去彩排，是去一個沒去過的教會彩排，彩排時也沒帶琴，直接用那個教會的琴 (記得是蠻初階的琴)，而開始彩排的第一首歌，我彈的第一個音與妹妹的琴聲與台下的歌聲同時出來，我瞬間充滿的雞皮疙瘩 (連現在回想也起雞皮疙瘩) ，音樂的美妙當下震撼了我，也可能是上帝讓我在當下被音樂所震撼了，造成了我有動力在音樂裡面不斷的練習與成長。\n第二次是在研究所的時候，我的論文是要做一個台灣沒什麼人設計的馬達種類，當時何博跟明賢哥給我的建議是，要先了解最基本的理論，所以我花了幾個月的時間，詳細的讀了電機機械，之後又讀了電動機設計，而且基本的理論理解後，每次有任何新的理論，都能跟基本的理論串起來，慢慢的累積了興趣，而真正產生觸動的，是當我把馬達設計出來，要做實驗的時候，看著它空載轉起來，電壓的數值接近計算的理論值，赫然間我能想像以前讀過的理論實際動起來的樣子，一種強烈的自我實現的感覺油然而生，瞬間雞皮疙瘩又跳了出來。\n第三次是完成後面文章的自動化馬達設計project的時候，當程式第一次執行起來，從規格數據計算參數、開啟ansys軟體、自動畫圖、自動分析、產出結果，這次不只是雞皮疙瘩，眼淚已經在眼眶打轉。\n結論 寫這篇花了我蠻長的時間用心回想與整理，純粹是我自己的感想與記錄，希望在以後面對的任何事情，能把想法都盡量轉向無限遊戲，而自己也在無限遊戲當中持續努力的耕耘，或許剛好看到文章的你，也與我共同在無限遊戲當中努力著，也如同書的最後一節\n世界上有且只有一種無限遊戲。\n","description":"看了一個說書的影片，覺得非常震撼，改變了很多看事情的想法，因此想寫下最近看完的感受，以後還可以回來溫習。","id":13,"section":"posts","tags":["mindset"],"title":"有限與無限的遊戲-心得","uri":"https://markwengstr.github.io/posts/%E6%9C%89%E9%99%90%E8%88%87%E7%84%A1%E9%99%90%E7%9A%84%E9%81%8A%E6%88%B2/"},{"content":"重點摘要 本篇取自SICP-1a，解釋最基礎的computer science\nWhat is computer science Process: 如何編寫解決問題的 \u0026ldquo;過程\u0026rdquo; Method: 組成process的元素，而method的名稱應該要陳述出裡面的知識 Computer science 的特性 處理\u0026quot; 理想化的元件\u0026quot;: 因為我們對所有要組合在一起的 data 與 function都能完全的掌控， 因此在理想與現實之間是差不多的 (如果是電子或機械工程師 那可能會需要考慮很多真實世界的限制)。 一個工程中的 \u0026ldquo;抽象形式\u0026rdquo;: 因為不需考慮現實的限制 Computer science 的技術 - 控制複雜度 black-box abstraction: 將功能封裝起來，使用的人不需要知道裡面的技術，只要呼叫它，丟入值就會輸出結果，而使用者又可以拿這個功能再去組合成更多功能。 將細節隱藏 (用以構建更大型的盒子) 具有通用性 (generality) Conventional interface: 如果系統裡的數據有許多不一樣的類型，計算的時候總不能混雜在一起，那怎麼辦呢? Generic operations large-scale structure and modularity object-oriented programming operations on aggregate (流) Metalinguistic Abstraction: 定義一個新語言 (用lisp做一個解析器來解析lisp)\n本篇不討論第二項與第三項，純粹討論最基礎的第一項。 用一個例子解釋何謂black-box abstraction Square root algorithm - 將數字開根號(x^0.5) 計算過程:\nMake a guess G (猜一個值 G) Improve the guess by average G and x/G (對於 G + x/G 的平均值做優化) Keep improving the guess until it is good enough (持續優化到足夠正確) 由上述的process，可以看出一個 \u0026ldquo;通則\u0026rdquo; (猜值 -\u0026gt; 優化 -\u0026gt; 持續優化到正確)，\n\u0026ldquo;找尋函數不動點\u0026rdquo; 的 定理為 F(函數)有一不動點值滿足 F(Y) = Y，\n而開根號的計算流程 ，可以視為 “找尋函數不動點” 這個通則 的其中一種方法: 找尋 Y與 x/Y的平均值函數的不動點。 (ex: F= (Y + x/Y)/2, 可以用 x = 36, Y = 6 來試試)\ncomputer science 就是透過設計各式各樣的元件來解決問題，SICP提供了撰寫元件時可依循的想法\n解決問題的時候，將流程寫出來。\n想想是否解決這個單一問題，是一個通用問題的其中一個應用 (產生自 通用函數 )\n看上述的問題，本來以為開根號函數非常的複雜，但抽出通用函數之後，我們把複雜度切成 Y, x/Y兩個參數的平均值 與“找尋函數不動點”的通用函數 這兩件事情，複雜度就被限縮在怎麼實作 \u0026ldquo;找尋函數不動點\u0026quot;這件事情上，這樣持續的做下去，複雜度是不是就層層的減低了呢?\n總結 black-box abstraction可由開根號函數看出，使用此函數其實不必知道開根號函數裡面的實作細節，反正調用它，就能達到需求，這是上述提到的第一個關鍵。 而第二個關鍵找到通用性是為了降低複雜度。\n當然這只是第一堂課，但也是最核心的觀念，後面會持續使用這個觀念來解決更多問題。\n","description":"the fundamental of computer science, black-box abstraction and Conventional interface","id":14,"section":"posts","tags":["sicp"],"title":"Functional programming serious - The Elements of Programming in SICP","uri":"https://markwengstr.github.io/posts/sicp_lec1a/"},{"content":"本文重點 非預期的共享，是大型系統的bug來源，透過給object一個身份(賦值) ，給它一個別名互相共享，是有蠻多方便，但也相對付出了代價。 但不賦值又怎麼能取用資料結構中的值呢? 能不能直接用function來解決以上問題?\n為计算机程序的构造和解释（Lec5b：计算对象) 後面部分的心得，整個影片都很值得看，但這篇要說的是從 46:35左右開始講的。且最近開始學Clojure，所以內容中操作的部分會用clojure來呈現。\n定義最簡單的資料結構 首先討論，什麼是 最簡單的資料結構(data structure)，任何 object 的最小單位就是一個pair。\n如何組成pair 就要談到組成pair的方法，叫做 cons 。\ncons 的定義 1 2 3 ;;對於任何的 x, y (car (cons x y)) = x (cdr (cons x y)) = y 簡單來說(cons x y)就是一個pair，也是最基本的資料結構。 就這個的定義來說，其實是一種抽象，cons包含兩個參數，如果兩個cons包含的參數是一樣的，那這兩個cons就是一樣的。\n不過，上述定義並沒有闡述，到底cons是否具有身份(identity)？\n給資料身分，引入賦值 如何解釋以下這段code ?\n1 (def a (cons 1 2)) 指的是在一個環境裡面，創造了一個名為 a 的 pair，這個pair裡面包含兩個指針一個指向1，一個指向2。\n再試著回答下列問題:\n假設又定義了一個 b (def b (cons a a))，那 b 這個pair指向的兩個a，是同一個a嗎？ 呈上，且現在呼叫 a 的方式有三種 a, (car b), (cdr b) ，哪個才是真正的呢？ 假設又用了賦值去改 car b (set-car! (car b) 3) ，原本存在 a 的 1被改成3了，現在如果再呼叫 (car a) 回傳的會是 3，儘管一開始我們定義的 (car a) 是1。 是不是有點難回答呢?\n賦值的危險 非預期的共享，是大型系統的bug來源，透過給object一個身份 ，給它一個別名互相共享，是有蠻多方便，但也相對付出了代價。\n當開始任意使用賦值，以下問題便開始產生\nChange: 變數不再代表一個值，可能會被改變 Time: 函式的回傳值，可能會因為時序的不同而不一樣 Identity: pair不再只是用car cdr去呼叫，它可以有別稱 Share: 兩個別稱之間有可能會共享同一個pair Data Structure is Just a function 為了盡量避免object的問題，能不能就把它當成數學的函式，而不要認為它是有身分的object呢 ?\n如何使用lambda function憑空製造一個 cons ! - by Alonzo Church 1 2 3 (defn cus-cons [x y] (fn [fc] (fc x y))) (defn cus-car [fc2] (fc2 (fn [a d] a))) (cus-car (cus-cons 1 2)) ;=\u0026gt; 1 是不是看不太懂? 沒關係，我來演繹一下這個神奇的程序\n1, 2被代換掉 cus-cons中的x, y，回傳了一個function (fn [fc] fc 1 2) 傳入 cus-car之後代換掉 fc2 : ((fn [fc] fc 1 2) (fn [a d] a)) ， (fn [a d] a) 被當成參數代換掉 fc 最後變成 ((fn [a b] a) 1 2) ，回傳值就是1了，超級神奇吧！ Lambda這個方式，完全是用function來完成 cons car cdr，並沒有存在任何一的地方。真的很有趣啊，推薦一定要去看一下傳說中的 Alonzo church lambda calculus！！！\n","description":"simple describe problem of identity of object and church encoding use clojure","id":15,"section":"posts","tags":["sicp","clojure"],"title":"SICP - Identity? of objects (by clojure)","uri":"https://markwengstr.github.io/posts/identity_of_objects/"},{"content":"WSL(Windows Subsystem for Linux) ubuntu 18.04 如何安裝 hugo 先將apt升級 1 2 sudo apt-get update -y sudo apt-get upgrade -y 下載指令 1 2 wget https://github.com/gohugoio/hugo/releases/download/v0.70.0/hugo_0.70.0_Linux-64bit.deb wget https://github.com/gohugoio/hugo/releases/download/v0.70.0/hugo_extended_0.70.0_Linux-64bit.deb 去hugo的github上找最新的release版本來下載，hugo 與 extend 都裝一下比較好，因為有些theme會用到sass/scss，像我用的zzo就會用。\n安裝指令 不推薦用apt裝是因為，apt的hugo版本不是最新的。\n1 2 sudo dpkg -i hugo_0.70.0_Linux-64bit.deb #寫文章時的最新版本是0.70.0 sudo dpkg -i hugo_extended_0.70.0_Linux-64bit.deb 裝完可以先用 hugo version 來看一下有沒有安裝成功。\n新增hugo專案指令 1 2 3 hugo new site xxxx # xxxx 請改成自己的專案名稱 cd xxxx hugo server 在瀏覽器開啟 localhost:1313 沒有錯誤就是OK摟，空白是正常的。\n選擇theme並開啟hugo 去 https://themes.gohugo.io/ 選個喜歡的theme吧! 我個人是選擇 zzo，因為很漂亮而且功能很齊全。\n要怎麼把theme裝到剛剛產生的hugo專案上呢，非常簡單的，照著以下步驟就行了。\n目前在xxxx目錄裡(以zzo為例)：\n1 2 3 4 \u0026lt;CTRL\u0026gt; + c (先關掉server) git init git clone https://github.com/zzossig/hugo-theme-zzo.git themes/zzo hugo server 就看theme的頁面裡面怎麼做，照做就是了。\ndeploy on github (以下是我自己的步驟，網路上其他人好像都用git submodule去管理，由於自己還不太熟悉，之後慢慢再更新)\n申請github帳號\n開兩個repositories\n一個放整個hugo專案，一個用來deploy上線(它只需要存hugo build出來的public資料夾就好)。\n放專案的名稱應該就是xxxx，而delpoy的要叫做 xxxx.github.io 。\n第一次要做的步驟： (以下為一系列commemd)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 目前在專案的目錄裡。 # 參考github push的步驟 git init git remote add origin https://github.com/\u0026lt;你的GitHub\u0026gt;/xxx.git vi .gitignore # 產生.gitignore # 按小寫英文a可以編輯，填入 public/，:wq 存取\u0026amp;退出 # 目的是不想讓產生的public使這個專案一直肥大 git push origin master # 首次推的話會需要名稱、email以及帳號密碼(每次都需要，除非額外設定，這邊不講) # Build the project. hugo # if using a theme, replace with `hugo -t \u0026lt;YOURTHEME\u0026gt;` # 將新產生的public folder複製到原本專案外 cp -r public ../ # Go To Public folder cd ../public # 再產生一個delpoy的git版本 git init git remote add origin https://github.com/\u0026lt;你的GitHub\u0026gt;/xxxx.github.io.git git push origin master 用瀏覽器開啟 www.xxxx.github.io 就可以看到啦!!!\n之後寫完文章要deploy的話，都可以利用以下指令來完成delpoy, 最好是寫成一個shell script以後run它就好。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #!/bin/sh # 在專案的目錄裡。 # If a command fails then the deploy stops set -e printf \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\\n\u0026#34; # remove old public file. rm public # Build the project. hugo # if using a theme, replace with `hugo -t \u0026lt;YOURTHEME\u0026gt;` # 將新產生的public folder複製到原本專案外 cp -r public ../ # Go To Public folder cd ../public # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site $(date)\u0026#34; if [ -n \u0026#34;$*\u0026#34; ]; then msg=\u0026#34;$*\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin master ","description":"從無到有利用hugo建立部落格 + delpoy github static page","id":16,"section":"posts","tags":["hugo"],"title":"用Hugo建立blog","uri":"https://markwengstr.github.io/posts/hugo-setup/"},{"content":"基本資料 本名: 翁佑甯 居住地: 高雄 專業 同步磁阻馬達SynRM, 永磁馬達pm motor 設計與測試 \u0026ndash; from 2012 全端網頁開發 full stack web development \u0026ndash; from 2018 高壓電機一~四級保養, ABB LEAP高壓電機線圈部分放電量測, ABB ability smart sensor 馬達智慧感測器 \u0026ndash; from 2021 馬達、發電機、變頻器、雲端智慧感測器 產品與維護方案銷售 \u0026ndash; from 2023 擅長工具 磁路分析軟體: Ansys maxwell, FEMM, JMAG Programming: linux, vim, ruby, python, javascript 音樂 2005年開始彈奏BASS 2014年開始接觸並練習爵士樂 2019年加入甘苦人樂團出了一張專輯 ","description":"My Stories to be continue...","id":17,"section":"","tags":null,"title":"關於我","uri":"https://markwengstr.github.io/about/"}]